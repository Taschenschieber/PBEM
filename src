(function() {
  var LocalStrategy, User, common, database, passport;

  common = require("./common");

  exports.passport = require("passport");

  passport = exports.passport;

  LocalStrategy = require("passport-local").Strategy;

  database = common.database;

  User = database.User;

  passport.use(new LocalStrategy(function(username, password, done) {
    return User.findOne({
      name: username
    }, function(err, user) {
      if (err) {
        return done(err);
      }
      if (user == null) {
        return done(null, false, "Invalid credentials.");
      }
      return user.comparePassword(password, function(err, valid) {
        if (err) {
          return done(err, false, err);
        }
        if (valid) {
          return done(null, user);
        } else {
          return done(null, false, "Invalid credentials.");
        }
      });
    });
  }));

  exports.setupRoutes = function(app) {
    app.post("/do/login", passport.authenticate("local", {
      successRedirect: "/games",
      failureRedirect: "/login",
      failureFlash: true
    }));
    app.get("/do/logout", function(req, res) {
      req.logout();
      return res.redirect("/");
    });
    return app.post("/do/signup", function(req, res) {
      var failed, flash, flashes, user, _i, _len;
      failed = false;
      flashes = [];
      if (req.body.username == null) {
        flashes.push("A username is required.");
        failed = true;
      }
      if (req.body.password1 == null) {
        flashes.push("A password is required.");
        failed = true;
      }
      if (req.body.password1 !== req.body.password2) {
        flashes.push("Passwords don't match.");
        failed = true;
      }
      if (req.body.email == null) {
        flashes.push("An E-Mail address is required.");
        failed = true;
      }
      if (failed) {
        console.log("failed signup attempt");
        for (_i = 0, _len = flashes.length; _i < _len; _i++) {
          flash = flashes[_i];
          req.flash("warning", flash);
        }
        return res.redirect("/signup");
      } else {
        console.log("successful signup attempt");
        user = new User({
          name: req.body.username,
          password: req.body.password1,
          email: req.body.email
        });
        return user.save(function(err, user) {
          if (err) {
            req.flash("error", err.message);
            return res.redirect("/error");
          } else {
            return res.redirect("/");
          }
        });
      }
    });
  };

  passport.serializeUser(function(user, done) {
    return done(null, user.name);
  });

  exports.getActiveUser = function(done) {
    var _ref;
    return passport.deserializeUser((_ref = req.user) != null ? _ref.username : void 0, function(err, user) {
      return done(err, user);
    });
  };

  passport.deserializeUser(function(user, done) {
    return User.findOne({
      name: user
    }, function(err, user) {
      return done(err, user);
    });
  });

}).call(this);

(function() {
  exports.database = require("./database");

  exports.auth = require("./auth");

}).call(this);

(function() {
  var Challenge, Notification, User, challenge, crypto, db, mongoose, notificationSchema, userSchema;

  exports.mongoose = mongoose = require("mongoose");

  crypto = require("crypto");

  db = mongoose.connection;

  db.on("error", console.error);

  db.once("open", function() {
    return console.log("DB connection established.");
  });

  mongoose.connect("mongodb://localhost/pbem");

  challenge = new mongoose.Schema({
    from: String,
    to: String,
    sent: {
      type: Date,
      "default": Date.now
    },
    timeControl: Number,
    scenarioId: String,
    dyo: Boolean,
    message: String
  });

  Challenge = mongoose.model("Challenge", challenge);

  exports.Challenge = Challenge;

  notificationSchema = new mongoose.Schema({
    username: String,
    text: String,
    action: String,
    date: {
      type: Date,
      "default": Date.now
    }
  });

  Notification = mongoose.model("Notification", notificationSchema);

  userSchema = new mongoose.Schema({
    name: String,
    password: String,
    email: String,
    challenges: [Challenge.schema]
  });

  userSchema.pre("save", function(next) {
    var user;
    user = this;
    if (!user.isModified("password")) {
      next();
    }
    user.password = crypto.createHash("sha256").update(user.password).digest("base64");
    return next();
  });

  userSchema.methods.comparePassword = function(candidatePassword, cb) {
    if (crypto.createHash("sha256").update(candidatePassword).digest("base64") === this.password) {
      return cb(null, true);
    } else {
      return cb(null, false);
    }
  };

  exports.User = User = mongoose.model("User", userSchema);

  exports.getUserByName = function(name, done) {
    return User.findOne({
      name: name
    }, function(err, user) {
      return done(err, user);
    });
  };

  exports.createNotification = function(username, message, action, done) {
    var notification;
    notification = new Notification({
      username: username,
      text: message,
      action: action
    });
    return notification.save(function(err) {
      return done(err);
    });
  };

  exports.getNotifications = function(username, done) {
    console.log("Start to load notifications for ", username);
    return Notification.find({
      username: username
    }).sort("-date").limit(10).exec(done);
  };

  exports.getNotification = function(id, done) {
    return Notification.find({
      _id: id
    }).exec(done);
  };

  exports.deleteNotification = function(id, done) {
    return Notification.remove({
      _id: id
    }).exec(done);
  };

  exports.findChallengersFor = function(userName, done) {
    return User.find({
      challenges: {
        $elemMatch: {
          to: userName
        }
      }
    }).sort("-date").exec(done);
  };

  exports.findChallengesFrom = function(userName, done) {
    return User.find({
      challenges: {
        $elemMatch: {
          from: userName
        }
      }
    }).sort("-date").exec(done);
  };

}).call(this);

(function() {
  var Challenge, Game, Log, Notification, User, challenge, crypto, db, game, log, mongoose, notificationSchema, userSchema;

  exports.mongoose = mongoose = require("mongoose");

  crypto = require("crypto");

  db = mongoose.connection;

  db.on("error", console.error);

  db.once("open", function() {
    return console.log("DB connection established.");
  });

  mongoose.connect("mongodb://localhost/pbem");

  log = new mongoose.Schema({
    sentBy: Boolean,
    empty: Boolean,
    date: {
      type: Date,
      "default": Date.now
    },
    comment: String
  });

  Log = mongoose.model("Log", log);

  exports.Log = log;

  game = new mongoose.Schema({
    playerA: String,
    playerB: String,
    kibitzers: [String],
    started: {
      type: Date,
      "default": Date.now
    },
    timeControl: String,
    scenarioId: String,
    logs: [Log.schema]
  });

  Game = mongoose.model("Game", game);

  exports.Game = Game;

  challenge = new mongoose.Schema({
    from: String,
    to: String,
    sent: {
      type: Date,
      "default": Date.now
    },
    timeControl: String,
    scenarioId: String,
    dyo: Boolean,
    message: String
  });

  Challenge = mongoose.model("Challenge", challenge);

  exports.Challenge = Challenge;

  notificationSchema = new mongoose.Schema({
    username: String,
    text: String,
    action: String,
    date: {
      type: Date,
      "default": Date.now
    }
  });

  Notification = mongoose.model("Notification", notificationSchema);

  userSchema = new mongoose.Schema({
    name: String,
    password: String,
    email: String
  });

  userSchema.pre("save", function(next) {
    var user;
    user = this;
    if (!user.isModified("password")) {
      next();
    }
    user.password = crypto.createHash("sha256").update(user.password).digest("base64");
    return next();
  });

  userSchema.methods.comparePassword = function(candidatePassword, cb) {
    if (crypto.createHash("sha256").update(candidatePassword).digest("base64") === this.password) {
      return cb(null, true);
    } else {
      return cb(null, false);
    }
  };

  exports.User = User = mongoose.model("User", userSchema);

  exports.getUserByName = function(name, done) {
    return User.findOne({
      name: name
    }, function(err, user) {
      return done(err, user);
    });
  };

  exports.createNotification = function(username, message, action, done) {
    var notification;
    notification = new Notification({
      username: username,
      text: message,
      action: action
    });
    return notification.save(function(err) {
      return done(err);
    });
  };

  exports.getNotifications = function(username, done) {
    console.log("Start to load notifications for ", username);
    return Notification.find({
      username: username
    }).sort("-date").limit(10).exec(done);
  };

  exports.getNotification = function(id, done) {
    return Notification.find({
      _id: id
    }).exec(done);
  };

  exports.deleteNotification = function(id, done) {
    return Notification.remove({
      _id: id
    }).exec(done);
  };

  exports.findChallengesFor = function(userName, done) {
    console.log("Find challenges for ", userName);
    return Challenge.find({
      to: userName
    }).sort("-date").exec(done);
  };

  exports.findChallengesFrom = function(userName, done) {
    return Challenge.find({
      from: userName
    }).sort("-date").exec(done);
  };

}).call(this);

(function() {
  var assembleData, common, database;

  common = require("./common");

  database = common.database;

  exports.setupRoutes = function(app) {
    app.get("/games", function(req, res) {
      return res.render("listActiveGames.jade", assembleData(req, res));
    });
    app.get("/games/challenge", function(req, res) {
      return res.render("issueChallenge.jade", assembleData(req, res));
    });
    app.get("/games/challenge/success", function(req, res) {
      return res.render("challengeIssued.jade", assembleData(req, res));
    });
    app.get("/games/my/challenges", function(req, res) {
      var data;
      data = assembleData(req, res);
      return database.findChallengesFor(req.user.name, function(err, challengers) {
        if (err) {
          return res.redirect("/error");
        }
        data.challengers = challengers || [];
        return database.findChallengesFrom(req.user.name, function(err, challenges) {
          if (err) {
            return res.redirect("/error");
          }
          data.challenges = challenges || [];
          return res.render("challenges.jade", data);
        });
      });
    });
    app.get("/games/my/active", function(req, res) {
      var data;
      data = assembleData(req, res);
      return database.Game.find({
        $or: [
          {
            playerA: req.user.name
          }, {
            playerB: req.user.name
          }
        ]
      }, function(err, games) {
        if (err) {
          res.send(err);
        }
        data.games = games;
        return res.render("mygames.jade", data);
      });
    });
    app.get("/game/:id", function(req, res) {
      var data;
      data = assembleData(req, res);
      return database.Game.findOne({
        _id: req.params.id
      }, function(err, game) {
        if (err || !game) {
          res.send(err);
        }
        data.game = game;
        return res.render("game.jade", data);
      });
    });
    app.get("/game/:id/upload", function(req, res) {
      return res.render("uploadLogfile.jade", assembleData(req, res));
    });
    app.post("/game/:id/upload/do", function(req, res) {
      var log;
      log = new database.Log({
        sentBy: req.user.name,
        empty: false
      });
      return database.Game.findOne({
        _id: req.params.id
      }).exec(function(err, game) {
        if (err || !game) {
          return res.send(err);
        }
        game.logs.push(log);
        return game.save(function(err) {
          if (err) {
            return res.send(err);
          }
          return console.log(log._id);
        });
      });
    });
    app.post("/do/games/challenge/issue", function(req, res) {
      var challenge, failed, _ref;
      failed = false;
      if (req.body.opponent == null) {
        failed = true;
        req.flash("error", "You have to select an opponent.");
      }
      if (req.body.timecontrol == null) {
        failed = true;
        req.flash("error", "Time control data missing.");
      }
      if (!((req.body.scenario != null) || req.body.dyo)) {
        failed = true;
        req.flash("Please select a scenario or DYO.");
      }
      if (((_ref = req.user) != null ? _ref.name : void 0) == null) {
        failed = true;
        req.flash("You are apparently not logged in.");
      }
      if (failed) {
        return res.redirect("/games/challenge");
      }
      challenge = new database.Challenge({
        from: req.user.name,
        to: req.body.opponent,
        timeControl: req.body.timecontrol,
        scenarioId: req.body.scenario,
        dyo: req.body.dyo,
        message: req.body.message
      });
      return challenge.save(function(err) {
        if (err) {
          req.flash("error", "Could not write to database: " + (err != null ? err.message : void 0));
          return res.redirect("/error");
        }
        database.createNotification(challenge.to, "You have been challenged to a match!", "/games/my/challenges", function(err) {
          return console.log(err || "Notification created");
        });
        return res.redirect("/games/challenge/success");
      });
    });
    app.get("/challenges/:id/accept", function(req, res) {
      return database.Challenge.findOne({
        _id: req.params.id
      }, function(err, challenge) {
        var game;
        if (err || !res) {
          res.render(err);
        }
        game = new database.Game({
          playerA: challenge.from,
          playerB: challenge.to,
          timeControl: challenge.timeControl,
          scenarioId: challenge.scenarioId
        });
        return game.save(function(err) {
          if (err) {
            res.send(err);
          }
          database.createNotification(challenge.to, req.user.name + " accepted your challenge!", "/game/" + game._id, function(err) {
            if (err) {
              return console.log(err);
            }
          });
          return res.redirect("/game/" + game._id);
        });
      });
    });
    app.get("/challenges/:id/decline", function(req, res) {
      return database.Challenge.findOne({
        _id: req.params.id
      }, function(err, challenge) {
        if (err || !res) {
          res.render(err);
        }
        database.createNotification(challenge.from, req.user.name + " declined your challenge. :(", "#", function(err) {
          if (err) {
            return console.log(err);
          }
        });
        return challenge.remove(function(err) {
          if (err) {
            return res.render(err);
          }
          return res.redirect("/games/my/challenges");
        });
      });
    });
    return app.get("/challenges/:id/takeback", function(req, res) {
      return database.Challenge.findOne({
        _id: req.params.id
      }, function(err, challenge) {
        if (err || !res) {
          res.render(err);
        }
        database.createNotification(challenge.to, req.user.name + " took back his challenge to you.", "#", function(err) {
          if (err) {
            return console.log(err);
          }
        });
        return challenge.remove(function(err) {
          if (err) {
            return res.render(err);
          }
          return res.redirect("/games/my/challenges");
        });
      });
    });
  };

  assembleData = function(req, res) {
    return {
      req: req,
      res: res
    };
  };

}).call(this);

(function() {
  module.exports = function(grunt) {
    grunt.initConfig({
      pkg: grunt.file.readJSON("package.json"),
      coffee: {
        glob_to_multiple: {
          files: {
            src: ["*.coffee"],
            dest: "/build",
            ext: ".js",
            expand: true,
            flatten: true
          }
        }
      }
    });
    grunt.loadNpmTasks("grunt-contrib-coffee");
    return grunt.registerTask("default", ["coffee"]);
  };

}).call(this);

(function() {
  var database;

  database = require("./database");

  exports.populate = function(req, res, next) {
    var _ref;
    console.log("Notifications.populate");
    if (((_ref = req.user) != null ? _ref.name : void 0) != null) {
      return database.getNotifications(req.user.name, function(err, notifications) {
        console.log("Notification loaded");
        req.user.notifications = notifications;
        console.log(notifications);
        return next();
      });
    } else {
      return next();
    }
  };

}).call(this);

(function() {
  var app, assembleData, auth, common, database, error, error404, express, flash, games, notifications;

  flash = require("connect-flash");

  express = require("express");

  common = require("./common");

  notifications = require("./notification-loader");

  app = express();

  database = common.database;

  auth = common.auth;

  games = require("./games");

  error = function(err, req, res, next) {
    return res.send("ERROR: ", err, "STACKTRACE: ", err.stack);
  };

  error404 = function(req, res, next) {
    return res.render("404.jade");
  };

  app.configure(function() {
    app.locals.pretty = true;
    app.use(express.cookieParser());
    app.use(express.bodyParser());
    app.use(express.session({
      secret: "fthagn"
    }));
    app.use(auth.passport.initialize());
    app.use(auth.passport.session());
    app.use(notifications.populate);
    app.use(flash());
    app.use(app.router);
    return app.use(express["static"](__dirname + "/pub"));
  });

  app.get("/", function(req, res) {
    return res.render("index.jade", assembleData(req, res));
  });

  app.get("/login", function(req, res) {
    return res.render("login.jade", assembleData(req, res));
  });

  app.get("/signup", function(req, res) {
    return res.render("signup.jade", assembleData(req, res));
  });

  app.get("/error", function(req, res) {
    return res.render("error.jade", assembleData(req, res));
  });

  auth.setupRoutes(app);

  games.setupRoutes(app);

  app.get("/notifications/:id", function(req, res) {
    return database.getNotification(req.params.id, function(err, notification) {
      var action;
      if (err || (notification == null)) {
        return res.send(err || "Unknown error");
      }
      action = notification.action || "/";
      database.deleteNotification(req.params.id, function() {});
      return res.redirect(action);
    });
  });

  app.listen(80);

  app.listen(8080);

  console.log("Server listening at 80+8080");

  assembleData = function(req, res) {
    return {
      req: req,
      res: res
    };
  };

}).call(this);
